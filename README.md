# Market Project

🛒 마켓 (Market) 백엔드 시스템
마켓 (Market) 이커머스 플랫폼의 백엔드 API 서버 프로젝트입니다. 이 시스템은 상품 관리, 장바구니, 주문 및 결제 등 온라인 스토어의 핵심 기능을 제공합니다.

<br>

✨ 현재 주요 기능
상품: 카테고리, 상품명, 가격 등 다양한 조건으로 상품을 검색하고 페이징된 목록을 조회합니다.

장바구니: 사용자별로 상품을 담고, 수량을 관리하며, 총액을 계산하는 기능을 제공합니다.

주문 및 결제: 장바구니 상품을 기반으로 주문을 생성하고, 재고를 관리하며, 외부 API를 통해 결제를 처리합니다.

🚀 API Endpoints
기능 Method URL 설명
상품 GET /api/products 조건에 따라 상품 목록 조회 (페이징 포함)
GET /api/products/{productId} 특정 상품 상세 정보 조회
장바구니 POST /api/cart/items 장바구니에 상품 추가
GET /api/cart 현재 사용자의 장바구니 조회
PATCH /api/cart/items/{cartItemId} 장바구니 상품 수량 변경
DELETE /api/cart/items/{cartItemId} 장바구니 특정 상품 삭제
DELETE /api/cart/items 장바구니 모든 상품 비우기
주문/결제 POST /api/orders 장바구니 상품으로 주문 생성
GET /api/orders/{orderId} 특정 주문 내역 조회
POST /api/orders/{orderId}/cancel 주문 취소
POST /api/payments/complete 결제 완료 처리 (외부 API 콜백)

⚙️ 기술적 결정 및 주요 고민 사항
프로젝트를 진행하며 마주한 기술적 문제들과 이를 해결하기 위한 결정 사항을 정리합니다.

1. 성능 최적화: N+1 문제 해결
   고민 내용:
   상품 목록을 조회할 때, 각 상품의 카테고리 정보를 함께 가져와야 합니다. 페이징 처리된 상품 목록을 조회하는 과정에서 각 상품마다 카테고리를 조회하는 N+1 문제가 발생할 수 있습니다.

해결 방안:
N+1 문제는 데이터베이스에 과도한 부하를 주어 성능을 저하 시키는 주된 원인입니다. 이 문제를 해결하기 위해 다음과 같은 접근법을 고려하고 적용했습니다.

Fetch Join: JPQL에서 JOIN FETCH를 사용하여 연관된 엔티티(예: Category)를 한 번의 쿼리로 함께 조회합니다. 관계가 복잡하지 않고, 페이징과 함께 사용할 때 발생하는 카티션 곱(Cartesian Product) 문제를 인지하고 제어할 수 있는 경우에 효과적입니다.

@EntityGraph: Repository 메서드에 @EntityGraph 어노테이션을 사용하여 Fetch Join과 유사한 효과를 냅니다. JPQL을 직접 작성하지 않아도 되어 코드가 간결해지는 장점이 있습니다.

DTO 프로젝션 (QueryDSL 활용): 복잡한 검색 조건과 동적 쿼리가 필요한 경우, QueryDSL을 사용하여 처음부터 필요한 데이터만 DTO로 조회합니다. 이 방법은 가장 유연하며, 필요한 데이터만 정확히 가져오므로 성능상 가장 이점이 많습니다.

결정: 본 프로젝트에서는 간단한 연관관계 조회는 Fetch Join을 우선적으로 사용하고, 복잡한 동적 검색이 필요한 상품 조회 API에서는 QueryDSL과 DTO 프로젝션을 채택하여 N+1 문제를 원천적으로 방지하고 성능을 최적화했습니다.

2. 데이터 모델링: 품절 상태 관리
   고민 내용:
   장바구니나 상품 목록 조회 시, 사용자는 상품의 품절 여부를 즉시 알 수 있어야 합니다. 이를 위해 별도의 status 컬럼을 두어야 할지, 아니면 재고(stock) 수량으로 계산해야 할지 결정이 필요했습니다.

해결 방안:

A) status 컬럼으로 관리: Product 테이블에 status (FOR_SALE, SOLD_OUT) 컬럼을 추가하는 방식.

장점: 조회 시 계산 로직 없이 바로 상태를 반환할 수 있어 읽기 성능이 빠릅니다.

단점: 재고 수량이 변경될 때마다 status를 동기화해야 하는 추가 작업이 필요하며, 데이터 정합성이 깨질 위험이 있습니다. (예: 재고는 있으나 상태가 SOLD_OUT인 경우)

B) stock 수량으로 동적 계산: stock > 0 여부를 실시간으로 계산하여 품절 상태를 판단하는 방식.

장점: 데이터가 항상 정확합니다. 별도의 동기화 로직이 필요 없습니다.

단점: 조회할 때마다 미세한 계산 비용이 발생합니다.

결정: 데이터의 정확성을 최우선으로 고려하여 동적 계산 방식을 기본으로 채택했습니다. 다만, 상품 자체가 단종되거나 관리자에 의해 판매 중단되는 경우를 위해 status 컬럼(SELLING, DISCONTINUED, DELETED)을 두어, 두 방식을 혼합하여 사용합니다. 즉, status가 SELLING이면서 stock > 0일 때만 '구매 가능' 상태가 됩니다.

3. 동시성 제어: 재고 관리
   고민 내용:
   재고가 1개 남은 상품을 여러 사용자가 동시에 주문하는 경우, 재고 이상의 주문이 발생하는 Race Condition이 발생할 수 있습니다. 이는 시스템의 신뢰도에 치명적입니다.

해결 방안:
재고 차감과 같이 데이터의 정합성이 매우 중요한 로직에서는 동시성 제어가 필수적입니다.

Pessimistic Lock (비관적 락): SELECT ... FOR UPDATE 구문을 사용하여 데이터베이스 레코드 자체에 락을 거는 방식입니다. 정합성을 확실하게 보장하지만, 락이 유지되는 동안 다른 트랜잭션이 대기해야 하므로 성능 저하를 유발할 수 있습니다.

Optimistic Lock (낙관적 락): 엔티티에 @Version 컬럼을 두는 방식입니다. 데이터를 수정할 때 버전 번호를 확인하여, 내가 조회한 이후 다른 트랜잭션에 의해 데이터가 변경되었다면 예외를 발생시킵니다. 락으로 인한 성능 저하가 없으므로 동시 요청이 많은 이커머스 환경에 더 적합합니다.

결정: 주문 및 결제와 같이 충돌이 예상되는 재고 차감 로직에서는 **Optimistic Lock (낙관적 락)**을 적용했습니다. 주문 처리 시 Product 엔티티의 @Version을 확인하여 데이터 변경 여부를 감지하고, 충돌이 발생하면 사용자에게 "재고가 변동되어 주문에 실패했습니다."와 같은 적절한 메시지를 반환하고 재시도를 유도합니다.

4. 주문 관리: 주문 상태 및 취소 정책
   고민 내용:
   주문은 생성부터 배송 완료까지 여러 상태를 거칩니다. 각 상태의 정의와 상태 전이가 명확해야 하며, 사용자가 주문을 취소할 수 있는 시점에 대한 정책이 필요합니다.

해결 방안:
주문 상태를 Enum (PENDING_PAYMENT, PAID, PREPARING_SHIPMENT, SHIPPED, DELIVERED, CANCELLED)으로 정의하여 명시적으로 관리합니다.

결정: 주문 취소는 "결제 완료" 상태(PAID)까지만 사용자가 직접 취소할 수 있도록 정책을 정했습니다. "배송 준비중"(PREPARING_SHIPMENT) 상태로 넘어가면 사용자는 직접 취소할 수 없으며, 고객센터를 통해서만 취소 절차를 밟도록 제한합니다. 이는 이미 물류 시스템과 연동되었을 가능성을 고려한 정책입니다.

🔧 시작하기
사전 요구사항
Java 17

Gradle 8.x

MySQL (또는 H2)

실행 방법
Bash

# 프로젝트 클론

git clone https://github.com/your-username/olla-market.git
cd olla-market

# Gradle 빌드

./gradlew build

# 애플리케이션 실행

java -jar build/libs/olla-market-0.0.1-SNAPSHOT.jar
🔮 향후 개선 과제
비회원 장바구니 기능: 현재는 회원 기반으로 동작합니다. 향후 세션 또는 쿠키를 활용한 비회원 장바구니 기능을 추가하여 사용자 경험을 확대할 계획입니다.

쿠폰 및 프로모션: 총액 기반 할인, 특정 상품 할인 등 다양한 프로모션 기능을 적용할 수 있는 구조로 확장합니다.
